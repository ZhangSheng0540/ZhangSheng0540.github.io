<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JDK1.7中HashMap源码解析</title>
      <link href="2021/06/02/HashMap%E6%BA%90%E7%A0%81/"/>
      <url>2021/06/02/HashMap%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="JDK1-7-HashMap"><a href="#JDK1-7-HashMap" class="headerlink" title="JDK1.7 HashMap"></a>JDK1.7 HashMap</h3><blockquote><p>JDK1.7中，HashMap是数组加链表的结构，每一个数组上存放的是Entry对象，Entry对象中有个next属性，指向下一个Entry对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap的内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... 省略get set hashcode equsl toString等方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16  初始容量大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;     <span class="comment">// 负载因子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用带参数的构造方法，给属性赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;   <span class="comment">//初始容量是16 负载因子是0.57</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">            loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();   <span class="comment">// 这个方法是个空的 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="put-key-操作方法"><a href="#put-key-操作方法" class="headerlink" title="put(key)操作方法"></a>put(key)操作方法</h4><blockquote><p>jdk1.7put操作采用的是头差法，头查法的效率比尾插法效率高，据说是考虑到热点数据的原因，即最近插入的元素也很可能最近会被使用到。每次put操作的时候，会先查看链表上是否存在已经有的key,所以得遍历查询，头插法从头开始遍历，查询到了冲突就返回了，尾插法得一直遍历到最后一个节点，没有冲突然后插入到最后。</p><p>然后对key进行hash计算，根据计算出来的结果获取底层数组的index（类似进行的取余计算 hashcode%size）,然后再将新插入的元素放到链表的头部位置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 懒加载的方式初始化map大小，</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);<span class="comment">// 将key为null的值存在Entry数组下边为0的位置上，如果之前已经有key为null的值了就覆盖</span></span><br><span class="line">    <span class="comment">// 2. 对key进行散列运算，返回一个hashcode值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 3. 计算对应key的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 4. 遍历链表上的数据，看是否有冲突的，有的话覆盖掉并返回旧数据</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next)&#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 5. 使用头插法插入数据</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>key的hash散列算法,</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化数组容量，初始化大小为大于initialCapacity的第一个2的幂次方作为容量<br><strong>原因：</strong></p><blockquote><ul><li>为了达到最可能的平均分配hashMap的valve的在table的各个index</li><li>2的幂次方进行二进制运算比取余运算效率快，</li></ul></blockquote></blockquote><blockquote><p>如果容量为2的N次方的话，那么hash&amp;(length-1) == hash%length;length转为二进制位一个1+N个0，length-1转为二进制位一个0+N个1；则任意的hash值和length-1做位运算，结构都是后面N个位的的二进制，因为length-1的二进制前面都是0，位运算后都是0，相当于舍弃了高位，保留了后面的N位，后面的N位刚好在0-length之间，也就是等于hash%length取余。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="comment">// 返回容量的2的高次幂，注意new hashmap(10) 最后的容量是16，因为这个方法会返回大于该数字的第一个2的幂作为容量</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 3-1</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="2021/06/01/java%E9%9B%86%E5%90%88/"/>
      <url>2021/06/01/java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h2><blockquote><h5 id="集合有两个基本接口：Collection和Map"><a href="#集合有两个基本接口：Collection和Map" class="headerlink" title="集合有两个基本接口：Collection和Map"></a>集合有两个基本接口：Collection和Map</h5></blockquote><blockquote><p>java中集合的用途，除了以Map结尾的类之外，其他类都实现了Collection接口，而以Map结尾的类实现了Map接口</p></blockquote><span id="more"></span><p><img src="./java%E9%9B%86%E5%90%88/collection-1.png" alt="java中集合"></p><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><blockquote><p>“for each”循环可以与任何实现了Iterable接口的对象一起工作<br>Collection接口扩展了Iterable接口。因此，对于标准类库中的任何集合都可以使用“for each”循环。</p></blockquote><h3 id="List是一个有序集合"><a href="#List是一个有序集合" class="headerlink" title="List是一个有序集合"></a>List是一个有序集合</h3><h4 id="LinkedList-链表结构-插入和删除快，查询慢"><a href="#LinkedList-链表结构-插入和删除快，查询慢" class="headerlink" title="LinkedList 链表结构 插入和删除快，查询慢"></a>LinkedList 链表结构 插入和删除快，查询慢</h4><blockquote><p>如果要查看链表中第n个元素，就必须从头开始，越过n-1个元素<br>get方法做了微小的优化：如果索引大于size() / 2就从列表尾端开始搜索元素</p></blockquote><h4 id="ArrayList-数组结构-随机查询快，插入和删除慢"><a href="#ArrayList-数组结构-随机查询快，插入和删除慢" class="headerlink" title="ArrayList 数组结构  随机查询快，插入和删除慢"></a>ArrayList 数组结构  随机查询快，插入和删除慢</h4><h4 id="Vector-线程安全的"><a href="#Vector-线程安全的" class="headerlink" title="Vector 线程安全的"></a>Vector 线程安全的</h4><h3 id="散列集-Set是无序的"><a href="#散列集-Set是无序的" class="headerlink" title="散列集 Set是无序的"></a>散列集 Set是无序的</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><blockquote><p>set是没有重复元素的元素集合。set的add方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java代理</title>
      <link href="2021/05/26/java%E4%BB%A3%E7%90%86/"/>
      <url>2021/05/26/java%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><blockquote><p>利用代理可以在运行时创建一个实现了一组给定接口的新类。</p></blockquote><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内部类</title>
      <link href="2021/05/21/java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>2021/05/21/java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><blockquote><p>使用内部类的原因：</p><ul><li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。</li><li>内部类可以对同一个包中的其他类隐藏起来。</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous）内部类比较便捷。</li></ul></blockquote><blockquote><p>内部类的对象总有一个隐式引用，它指向了创建它的外部类对象。</p></blockquote><blockquote><p>只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性<br>内部类中声明的所有静态域都必须是final。<br>内部类不能有static方法。</p></blockquote><blockquote><p>内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用$（美元符号）分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。</p></blockquote><span id="more"></span><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><blockquote><p>在方法中定义的一个类<br>局部类不能用public或private访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。</p></blockquote><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><blockquote><p>假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类（anonymous inner class）。</p></blockquote><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><blockquote><ul><li>在内部类不需要访问外围类对象的时候，应该使用静态内部类。有些程序员用嵌套类（nested class）表示静态内部类。</li><li>与常规内部类不同，静态内部类可以有静态域和方法</li><li>声明在接口中的内部类自动成为static和public类。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="2021/05/20/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2021/05/20/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="lambda名称的由来"><a href="#lambda名称的由来" class="headerlink" title="lambda名称的由来"></a>lambda名称的由来</h3><blockquote><p>很多年前，那时还没有计算机，逻辑学家Alonzo Church想要形式化地表示能有效计算的数学函数。（奇怪的是，有些函数已经知道是存在的，但是没有人知道该如何计算这些函数的值。）他使用了希腊字母lambda (λ)来标记参数。</p><p>为什么是字母λ? Church已经把字母表里的所有其他字母都用完了吗？实际上，权威的《数学原理》一书中就使用重音符^来表示自由变量，受此启发，Church使用大写lambda（Λ）表示参数。不过，最后他还是改为使用小写的lambda(λ)。从那以后，带参数变量的表达式就被称为lambda表达式。</p></blockquote><span id="more"></span><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><blockquote><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口（functional interface）。</p></blockquote><blockquote><ol><li>一个函数式接口有且只有一个抽象方法（不一定非得用@FunctionalInterface注解，但建议使用注解，因为但你无意中增加了另一个非抽象方法编译器会提示错误消息）。</li><li>默认方法不是抽象方法，因为它们已经实现了。</li><li>重写了超类Object类中任意一个public方法的方法并不算接口中的抽象方法。</li></ol></blockquote><h3 id="组成lambda表达式的3部分"><a href="#组成lambda表达式的3部分" class="headerlink" title="组成lambda表达式的3部分"></a>组成lambda表达式的3部分</h3><blockquote><ul><li>一个代码块</li><li>参数</li><li>自由变量的值，这是指非参数而且不在代码中定义的变量。</li></ul></blockquote><h3 id="lambda表达式的重点是延迟执行-这个有很多原因，如："><a href="#lambda表达式的重点是延迟执行-这个有很多原因，如：" class="headerlink" title="lambda表达式的重点是延迟执行,这个有很多原因，如："></a>lambda表达式的重点是延迟执行,这个有很多原因，如：</h3><blockquote><ul><li>在一个单独的线程中运行代码；</li><li>多次运行代码；</li><li>在算法的适当位置运行代码（例如，排序中的比较操作）；</li><li>发生某种情况时执行代码（如，点击了一个按钮，数据到达，等等）；</li><li>只在必要时才运行代码。</li></ul></blockquote><h3 id="常用的函数式接口"><a href="#常用的函数式接口" class="headerlink" title="常用的函数式接口"></a>常用的函数式接口</h3><p><img src="lambda_1.png" alt="常用的函数式接口"><br><img src="lambda-2.png" alt="基本类型函数式接口"></p><h3 id="Comparator接口示例"><a href="#Comparator接口示例" class="headerlink" title="Comparator接口示例"></a>Comparator接口示例</h3><p><img src="Comparator.png" alt="comparator示例"></p>]]></content>
      
      
      <categories>
          
          <category> lambda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 接口</title>
      <link href="2021/05/19/interface/"/>
      <url>2021/05/19/interface/</url>
      
        <content type="html"><![CDATA[<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote><p>接口决不能含有实例域，可以包含常量<br>在Java SE 8中，可以为接口方法提供一个默认实现。必须用default修饰符标记这样一个方法<br>在Java SE 8中，允许在接口中增加静态方法</p></blockquote><span id="more"></span><h4 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h4><blockquote><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况？</p><ol><li>超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li><li>接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突。</li></ol></blockquote><h3 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h3><blockquote><p>Object.clone() 默认是浅拷贝 如果对象中的所有数据域都是数值或其他基本类型，拷贝这些域没有任何问题。但是如果对象包含子对象的引用，拷贝域就会得到相同子对象的另一个引用，这样一来，原对象和克隆的对象仍然会共享一些信息。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基本特性</title>
      <link href="2021/05/19/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1/"/>
      <url>2021/05/19/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1/</url>
      
        <content type="html"><![CDATA[<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><blockquote><ul><li>只能在继承层次内进行类型转换。</li><li>在将超类转换成子类之前，应该使用instanceof进行检查。</li></ul></blockquote><h3 id="Java用于控制可见性的4个访问修饰符"><a href="#Java用于控制可见性的4个访问修饰符" class="headerlink" title="Java用于控制可见性的4个访问修饰符"></a>Java用于控制可见性的4个访问修饰符</h3><blockquote><ol><li>仅对本类可见——private。</li><li>对所有类可见——public。</li><li>对本包和所有子类可见——protected。</li><li>对本包可见——默认（很遗憾），不需要修饰符。</li></ol></blockquote><span id="more"></span><h3 id="自动拆箱自动装箱"><a href="#自动拆箱自动装箱" class="headerlink" title="自动拆箱自动装箱"></a>自动拆箱自动装箱</h3><blockquote><p>自动装箱规范要求boolean、byte、char≤127，介于-128～127之间的short和int被包装到固定的对象中。<br>例如，如果将a和b初始化为100，对它们进行比较的结果一定成立。</p></blockquote><blockquote><p>另外，如果在一个条件表达式中混合使用Integer和Double类型，Integer值就会拆箱，提升为double，再装箱为Double：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="number">1</span>;</span><br><span class="line">Double d = <span class="number">2.0</span>;</span><br><span class="line">System.out.println(<span class="keyword">true</span> ? n : <span class="number">2.0</span>); <span class="comment">// 输出1.0</span></span><br></pre></td></tr></table></figure><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><blockquote><p>能够分析类能力的程序称为反射（reflective）。反射机制的功能：</p><ul><li>在运行时分析类的能力。</li><li>在运行时查看对象，例如，编写一个toString方法供所有类使用。</li><li>实现通用的数组操作代码。</li><li>利用Method对象，调用任意方法。</li></ul></blockquote><h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><blockquote><ul><li>将公共操作和域放在超类</li><li>不要使用受保护的域</li><li>使用继承实现“is-a”关系  (看创建的类是否满足这种关系)</li><li>除非所有继承的方法都有意义，否则不要使用继承</li><li>在覆盖方法时，不要改变预期的行为 (在覆盖子类中的方法时，不要偏离最初的设计想法)</li><li>使用多态，而非类型信息 (使用多态方法或接口编写的代码比使用对多种类型进行检测的代码更加易于维护和扩展)</li><li>不要过多地使用反射</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面向对象</title>
      <link href="2021/05/18/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/05/18/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="java对象"><a href="#java对象" class="headerlink" title="java对象"></a>java对象</h3><blockquote><p>对象的三个特征</p><ul><li>对象的行为（behavior）——可以对对象施加哪些操作，或可以对对象施加哪些方法？</li><li>对象的状态（state）——当施加那些方法时，对象如何响应？</li><li>对象标识（identity）——如何辨别具有相同行为与状态的不同对象？</li></ul></blockquote><blockquote><p>同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。</p><p>此外，每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变，但这种改变不会是自发的。对象状态的改变必须通过调用方法实现（如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏）。</p></blockquote><span id="more"></span><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><blockquote><p>在类之间，最常见的关系</p><ul><li>依赖（“uses-a”） 如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类</li><li>聚合（“has-a”）  聚合关系意味着类A的对象包含类B的对象</li><li>继承（“is-a”）    是一种用于表示特殊与一般关系的</li></ul></blockquote><p><img src="UML_image.jpg" alt="类关系UML符号"></p><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><blockquote><p>按值调用（callby value）表示方法接收的是调用者提供的值。而按引用调用（call by reference）表示方法接收的是调用者提供的变量地址。</p><p>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p></blockquote><blockquote><p>Java中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul></blockquote><h3 id="类的设计技巧"><a href="#类的设计技巧" class="headerlink" title="类的设计技巧"></a>类的设计技巧</h3><blockquote><ol><li>一定要保证数据私有</li><li>一定要对数据初始化</li><li>不要在类中使用过多的基本类型</li><li>不是所有的域都需要独立的域访问器和域更改器</li><li>将职责过多的类进行分解</li><li>类名和方法名要能够体现它们的职责</li><li>优先使用不可变的类</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中String类中一些方法</title>
      <link href="2021/05/17/java%E4%B8%ADString%E7%B1%BB%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/"/>
      <url>2021/05/17/java%E4%B8%ADString%E7%B1%BB%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String sub = s.substring(<span class="number">0.3</span>)  <span class="comment">//sub的结果为hel </span></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><blockquote><p>如果需要把多个字符串放在一起，用一个定界符分隔，可以使用静态join方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = String.join(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>) <span class="comment">//  结果为A/B</span></span><br></pre></td></tr></table></figure><blockquote><p>不可变字符串 优缺点：</p><ul><li>缺点： 运行效率低</li><li>优点： 编译器可让字符串共享</li></ul><p>为了弄清具体的工作方式，可以想象将各种字符串存放在公共的存储池中。字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。</p><p>总而言之，Java的设计者认为共享带来的高效率远远胜过于提取、拼接字符串所带来的低效率。查看一下程序会发现：很少需要修改字符串，而是往往需要对字符串进行比较（有一种例外情况，将来自于文件或键盘的单个字符或较短的字符串汇集成字符串)。</p></blockquote><h3 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.equals(b);   <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span>.equalsIgnoreCase(<span class="string">&quot;Hello&quot;</span>)  <span class="comment">// true  忽略大小写</span></span><br></pre></td></tr></table></figure><blockquote><p>一定不要使用==运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否放置在同一个位置上。当然，如果字符串放置在同一个位置上，它们必然相等。但是，完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上。</p></blockquote><blockquote><p>如果虚拟机始终将相同的字符串共享，就可以使用==运算符检测是否相等。但实际上只有字符串常量是共享的，而+或substring等操作产生的结果并不是共享的。因此，千万不要使用==运算符测试字符串的相等性，以免在程序中出现糟糕的bug。从表面上看，这种bug很像随机产生的间歇性错误。</p></blockquote><h3 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String strignBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">strignBuilder.appand(<span class="string">&quot;ch&quot;</span>);</span><br><span class="line">strignBuilder.appand(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">strignBuilder.toString();    <span class="comment">//chstr</span></span><br></pre></td></tr></table></figure><blockquote><p>StringBuilder线程不安全的，StringBuffer线程安全的</p></blockquote><h3 id="获取启动路径（绝对路径）"><a href="#获取启动路径（绝对路径）" class="headerlink" title="获取启动路径（绝对路径）"></a>获取启动路径（绝对路径）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String strignBuilder = System.getProperty(<span class="string">&quot;user.dir&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><blockquote><p>块（即复合语句）是指由一对大括号括起来的若干条简单的Java语句。块确定了变量的作用域。</p></blockquote><blockquote><p>但是，不能在嵌套的两个块中声明同名的变量</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo发生error：spawn failed错误的解决方法</title>
      <link href="2021/05/12/hexo%E5%8F%91%E7%94%9Ferror%EF%BC%9Aspawn-failed%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>2021/05/12/hexo%E5%8F%91%E7%94%9Ferror%EF%BC%9Aspawn-failed%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>执行hexo d 命令的时候出现这个错误</li></ul><h2 id="造成原因"><a href="#造成原因" class="headerlink" title="造成原因"></a>造成原因</h2><ul><li>因为git进行push或者hexo d的时候改变了一些.deploy_git文件下的内容。</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><span id="more"></span><ul><li>删除.deploy_git文件夹;</li><li>输入git config –global core.autocrlf false</li><li>然后，依次执行：<blockquote><p>   hexo clean<br>   hexo g<br>   hexo d</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/11/hello-world/"/>
      <url>2021/05/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Testing </tag>
            
            <tag> Another Tag </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
